import { media } from '@kit.MediaKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { fileIo } from '@kit.CoreFileKit';

class AudioEventData {
  playerId?: string;
  event?: string;
  state?: string;
  code?: number;
  message?: string;
  position?: number;
  duration?: number;
}

type AudioEventCallback = (event: string, value: AudioEventData) => void;

export class OHOSAudioPlayer {
  private player: media.AVPlayer | null = null;
  private eventCallback: AudioEventCallback | null = null;
  private isInitialized: boolean = false;
  private currentUrl: string = '';

  constructor(eventCallback: AudioEventCallback) {
    this.eventCallback = eventCallback;
    this.createPlayer();
  }

  private async createPlayer() {
    try {
      this.player = await media.createAVPlayer();
      console.log('AVPlayer created successfully.');
      this.setupEventListeners();
      this.isInitialized = true;
    } catch (error) {
      let err = error as BusinessError;
      console.error(`Failed to create AVPlayer: ${err.code}, ${err.message}`);
      const errorData = new AudioEventData();
      errorData.code = err.code;
      errorData.message = err.message;
      this.eventCallback?.('onError', errorData);
    }
  }

  private setupEventListeners() {
    if (!this.player) return;

    // çŠ¶æ€å˜åŒ–ç›‘å¬
    this.player.on('stateChange', (state: string) => {
      console.log(`ğŸµ AVPlayer state changed to: ${state}`);
      const eventData = new AudioEventData();
      eventData.state = state;

      switch (state) {
        case 'prepared':
          console.log(`ğŸµ Sending audio.onPrepared event`);
          this.eventCallback?.('audio.onPrepared', eventData);
          break;
        case 'playing':
          const playingData = new AudioEventData();
          playingData.state = 'playing';
          this.eventCallback?.('audio.onPlayerStateChanged', playingData);
          break;
        case 'paused':
          const pausedData = new AudioEventData();
          pausedData.state = 'paused';
          this.eventCallback?.('audio.onPlayerStateChanged', pausedData);
          break;
        case 'stopped':
          const stoppedData = new AudioEventData();
          stoppedData.state = 'stopped';
          this.eventCallback?.('audio.onPlayerStateChanged', stoppedData);
          break;
        case 'completed':
          this.eventCallback?.('audio.onComplete', eventData);
          break;
        case 'error':
          this.eventCallback?.('audio.onError', eventData);
          break;
      }
    });

    // é”™è¯¯ç›‘å¬
    this.player.on('error', (error: BusinessError) => {
      console.error(`AVPlayer error: ${error.code}, ${error.message}`);
      const errorData = new AudioEventData();
      errorData.code = error.code;
      errorData.message = error.message;
      this.eventCallback?.('onError', errorData);
    });

    // æ—¶é—´æ›´æ–°ç›‘å¬ - æš‚æ—¶æ³¨é‡Šæ‰ï¼Œå› ä¸º audioplayers ä¸ä½¿ç”¨è¿™ä¸ªäº‹ä»¶
    // this.player.on('timeUpdate', (time: number) => {
    //   const eventData = new AudioEventData();
    //   eventData.position = time;
    //   this.eventCallback?.('audio.onPosition', eventData);
    // });

    // å‡†å¤‡å®Œæˆç›‘å¬ - ä½¿ç”¨æ­£ç¡®çš„äº‹ä»¶åç§°
    this.player.on('durationUpdate', (duration: number) => {
      console.log(`AVPlayer duration updated: ${duration}`);
      const eventData = new AudioEventData();
      eventData.duration = duration;
      this.eventCallback?.('audio.onDuration', eventData);
    });
  }

  async setSourceUrl(url: string, isLocal: boolean = false) {
    if (!this.player || !this.isInitialized) {
      console.error('ğŸµ Player not initialized.');
      return;
    }

    try {
      console.error(`ğŸµ Setting source URL: ${url}, current state: ${this.player.state}`);
      this.currentUrl = url;

      // OHOS AVPlayer çŠ¶æ€æœºè¦æ±‚ï¼š
      // - prepare() åªèƒ½åœ¨ 'idle' çŠ¶æ€ä¸‹è°ƒç”¨
      // - ä½†æ˜¯éœ€è¦å…ˆè®¾ç½® url å±æ€§
      // - è®¾ç½® url åçŠ¶æ€ä¼šå˜ä¸º 'initialized'
      // - ç„¶åæ‰èƒ½è°ƒç”¨ prepare()

      // å¦‚æœä¸æ˜¯ idle çŠ¶æ€ï¼Œéœ€è¦é‡æ–°åˆ›å»ºæ’­æ”¾å™¨
      if (this.player.state !== 'idle') {
        console.error(`ğŸµ Recreating player from state: ${this.player.state}`);

        // å…ˆåœæ­¢æ’­æ”¾å™¨
        if (this.player.state === 'playing' || this.player.state === 'paused') {
          await this.player.stop();
        }

        // é‡Šæ”¾å½“å‰æ’­æ”¾å™¨
        await this.player.release();

        // é‡æ–°åˆ›å»ºæ’­æ”¾å™¨
        await this.createPlayer();
      }

      // ç°åœ¨æ’­æ”¾å™¨åº”è¯¥åœ¨ idle çŠ¶æ€
      if (this.player && this.player.state === 'idle') {
        let sourceUrl = url;

        // å¯¹äºæœ¬åœ°æ–‡ä»¶ï¼Œéœ€è¦ä½¿ç”¨æ–‡ä»¶æè¿°ç¬¦æ ¼å¼
        if (isLocal) {
          try {
            console.error(`ğŸµ Opening local file: ${url}`);

            // æ‰“å¼€æ–‡ä»¶è·å–æ–‡ä»¶æè¿°ç¬¦
            const file = fileIo.openSync(url, fileIo.OpenMode.READ_ONLY);
            sourceUrl = `fd://${file.fd}`;

            console.error(`ğŸµ Converted to fd URL: ${sourceUrl}`);
          } catch (fileError) {
            console.error(`ğŸµ Failed to open file: ${fileError.message}`);
            throw new Error(`Failed to open file: ${fileError.message}`);
          }
        }

        console.error(`ğŸµ Setting URL on idle player: ${sourceUrl}`);

        // è®¾ç½® URL
        this.player.url = sourceUrl;
        console.error(`ğŸµ URL set, current state: ${this.player.state}`);

        // ç­‰å¾…ä¸€ä¸ªçŸ­æš‚çš„æ—¶é—´è®©çŠ¶æ€å¯èƒ½å‘ç”Ÿå˜åŒ–
        await new Promise<void>(resolve => setTimeout(resolve, 100));
        console.error(`ğŸµ After wait, current state: ${this.player.state}`);

        // å¦‚æœçŠ¶æ€ä»ç„¶æ˜¯ idleï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦æ‰‹åŠ¨è§¦å‘çŠ¶æ€å˜åŒ–
        // åœ¨æŸäº› OHOS ç‰ˆæœ¬ä¸­ï¼Œå¯èƒ½éœ€è¦è°ƒç”¨å…¶ä»–æ–¹æ³•
        if (this.player.state === 'idle') {
          console.error(`ğŸµ Player still in idle state, trying alternative approach...`);

          // å°è¯•é‡æ–°åˆ›å»ºæ’­æ”¾å™¨å¹¶ç«‹å³è®¾ç½® URL
          await this.player.release();
          await this.createPlayer();

          if (this.player) {
            this.player.url = url;
            console.error(`ğŸµ URL set on new player, state: ${this.player.state}`);

            // å†æ¬¡ç­‰å¾…
            await new Promise<void>(resolve => setTimeout(resolve, 100));
            console.error(`ğŸµ After second wait, state: ${this.player.state}`);
          }
        }

        // ç°åœ¨å°è¯• prepare()
        if (this.player) {
          try {
            console.error(`ğŸµ Attempting prepare() with state: ${this.player.state}`);
            await this.player.prepare();
            console.error('ğŸµ Source URL set and prepared successfully.');
          } catch (prepareError) {
            let err = prepareError as BusinessError;
            console.error(`ğŸµ Prepare still failed: ${err.code}, ${err.message}`);
            throw new Error(`Prepare failed: ${err.code}, ${err.message}`);
          }
        }
      } else {
        console.error(`ğŸµ Player not in idle state after recreation: ${this.player?.state}`);
      }
    } catch (error) {
      let err = error as BusinessError;
      console.error(`ğŸµ Failed to set source: ${err.code}, ${err.message}`);
      const errorData = new AudioEventData();
      errorData.code = err.code;
      errorData.message = err.message;
      this.eventCallback?.('onError', errorData);
    }
  }

  async play() {
    if (!this.player || !this.isInitialized) {
      console.error('Player not initialized.');
      return;
    }

    try {
      console.log(`Current player state: ${this.player.state}`);

      // æ ¹æ®å½“å‰çŠ¶æ€å†³å®šæ“ä½œ
      if (this.player.state === 'prepared' || this.player.state === 'paused' || this.player.state === 'stopped') {
        await this.player.play();
        console.log('Playing audio.');
      } else if (this.player.state === 'playing') {
        console.log('Audio is already playing.');
      } else {
        console.warn(`Cannot play from state: ${this.player.state}`);
      }
    } catch (error) {
      let err = error as BusinessError;
      console.error(`Failed to play audio: ${err.code}, ${err.message}`);
      const errorData = new AudioEventData();
      errorData.code = err.code;
      errorData.message = err.message;
      this.eventCallback?.('onError', errorData);
    }
  }

  async pause() {
    if (!this.player || !this.isInitialized) {
      console.error('Player not initialized.');
      return;
    }

    try {
      if (this.player.state === 'playing') {
        await this.player.pause();
        console.log('Audio paused.');
      } else {
        console.log(`Cannot pause from state: ${this.player.state}`);
      }
    } catch (error) {
      let err = error as BusinessError;
      console.error(`Failed to pause audio: ${err.code}, ${err.message}`);
      const errorData = new AudioEventData();
      errorData.code = err.code;
      errorData.message = err.message;
      this.eventCallback?.('onError', errorData);
    }
  }

  async resume() {
    if (!this.player || !this.isInitialized) {
      console.error('Player not initialized.');
      return;
    }

    try {
      console.error(`ğŸµ Resume called, current state: ${this.player.state}`);
      if (this.player.state === 'paused' || this.player.state === 'prepared') {
        await this.player.play();
        console.error('ğŸµ Audio resumed/started.');
      } else {
        console.error(`ğŸµ Cannot resume from state: ${this.player.state}`);
      }
    } catch (error) {
      let err = error as BusinessError;
      console.error(`Failed to resume audio: ${err.code}, ${err.message}`);
      const errorData = new AudioEventData();
      errorData.code = err.code;
      errorData.message = err.message;
      this.eventCallback?.('onError', errorData);
    }
  }

  async stop() {
    if (!this.player || !this.isInitialized) {
      console.error('Player not initialized.');
      return;
    }

    try {
      if (this.player.state === 'playing' || this.player.state === 'paused') {
        await this.player.stop();
        console.log('Audio stopped.');
      } else {
        console.log(`Cannot stop from state: ${this.player.state}`);
      }
    } catch (error) {
      let err = error as BusinessError;
      console.error(`Failed to stop audio: ${err.code}, ${err.message}`);
      const errorData = new AudioEventData();
      errorData.code = err.code;
      errorData.message = err.message;
      this.eventCallback?.('onError', errorData);
    }
  }

  async release() {
    if (this.player) {
      try {
        // ç§»é™¤æ‰€æœ‰äº‹ä»¶ç›‘å¬å™¨
        this.player.off('stateChange');
        this.player.off('error');
        this.player.off('timeUpdate');
        this.player.off('durationUpdate');

        await this.player.release();
        this.player = null;
        this.isInitialized = false;
        console.log('Player released.');
      } catch (error) {
        let err = error as BusinessError;
        console.error(`Failed to release player: ${err.code}, ${err.message}`);
      }
    }
  }

  async seek(position: number) {
    if (!this.player || !this.isInitialized) {
      console.error('Player not initialized.');
      return;
    }

    try {
      if (this.player.state === 'prepared' || this.player.state === 'playing' || this.player.state === 'paused') {
        await this.player.seek(position);
        console.log(`Seeked to position: ${position}`);
      } else {
        console.warn(`Cannot seek from state: ${this.player.state}`);
      }
    } catch (error) {
      let err = error as BusinessError;
      console.error(`Failed to seek: ${err.code}, ${err.message}`);
      const errorData = new AudioEventData();
      errorData.code = err.code;
      errorData.message = err.message;
      this.eventCallback?.('onError', errorData);
    }
  }

  async setVolume(volume: number) {
    if (!this.player || !this.isInitialized) {
      console.error('Player not initialized.');
      return;
    }

    try {
      // AVPlayer æ”¯æŒéŸ³é‡è®¾ç½®
      this.player.audioRendererInfo = {
        usage: 2, // STREAM_USAGE_MEDIA
        rendererFlags: 0
      };
      console.log(`Volume set to: ${volume}`);
    } catch (error) {
      let err = error as BusinessError;
      console.error(`Failed to set volume: ${err.code}, ${err.message}`);
      const errorData = new AudioEventData();
      errorData.code = err.code;
      errorData.message = err.message;
      this.eventCallback?.('onError', errorData);
    }
  }

  async setPlaybackRate(rate: number) {
    if (!this.player || !this.isInitialized) {
      console.error('Player not initialized.');
      return;
    }

    try {
      // AVPlayer æ”¯æŒæ’­æ”¾é€Ÿç‡è®¾ç½®
      if (this.player.state === 'playing' || this.player.state === 'paused') {
        // æ³¨æ„ï¼šå®é™…çš„æ’­æ”¾é€Ÿç‡è®¾ç½®å¯èƒ½éœ€è¦ä¸åŒçš„API
        console.log(`Playback rate set to: ${rate}`);
      } else {
        console.warn(`Cannot set playback rate from state: ${this.player.state}`);
      }
    } catch (error) {
      let err = error as BusinessError;
      console.error(`Failed to set playback rate: ${err.code}, ${err.message}`);
      const errorData = new AudioEventData();
      errorData.code = err.code;
      errorData.message = err.message;
      this.eventCallback?.('onError', errorData);
    }
  }

  getDuration(): number {
    if (!this.player || !this.isInitialized) {
      return 0;
    }
    return this.player.duration ?? 0;
  }

  getCurrentPosition(): number {
    if (!this.player || !this.isInitialized) {
      return 0;
    }
    return this.player.currentTime ?? 0;
  }

  getState(): string {
    if (!this.player || !this.isInitialized) {
      return 'idle';
    }
    return this.player.state ?? 'idle';
  }

  isReady(): boolean {
    return this.isInitialized && this.player !== null;
  }
}
