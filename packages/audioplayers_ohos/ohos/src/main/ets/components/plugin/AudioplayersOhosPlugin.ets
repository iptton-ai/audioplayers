import {
  FlutterPlugin,
  FlutterPluginBinding,
  MethodCall,
  MethodCallHandler,
  MethodChannel,
  MethodResult,
  EventChannel,
  EventSink,
  StreamHandler,
  BinaryMessenger,
} from '@ohos/flutter_ohos';
import { OHOSAudioPlayer } from './OHOSAudioPlayer';

class AudioEventData {
  playerId?: string;
  event?: string;
  state?: string;
  code?: number;
  message?: string;
  position?: number;
  duration?: number;
}

class GlobalEventStreamHandler implements StreamHandler {
  private eventSink: EventSink | null = null;

  onListen(args: Object, eventSink: EventSink): void {
    this.eventSink = eventSink;
  }

  onCancel(args: Object): void {
    this.eventSink = null;
  }

  sendEvent(event: Record<string, Object>): void {
    this.eventSink?.success(event);
  }
}

class PlayerEventStreamHandler implements StreamHandler {
  private eventSink: EventSink | null = null;

  onListen(args: Object, eventSink: EventSink): void {
    this.eventSink = eventSink;
  }

  onCancel(args: Object): void {
    this.eventSink = null;
  }

  sendEvent(event: Record<string, Object>): void {
    this.eventSink?.success(event);
  }
}

class GlobalMethodCallHandler implements MethodCallHandler {
  private plugin: AudioplayersOhosPlugin;

  constructor(plugin: AudioplayersOhosPlugin) {
    this.plugin = plugin;
  }

  onMethodCall(call: MethodCall, result: MethodResult): void {
    const args = call.args as Record<string, Object>;
    console.error(`ğŸµ OHOS Plugin: Global method called: ${call.method}, args: ${JSON.stringify(args)}`);

    switch (call.method) {
      case "init":
        this.plugin.handleGlobalInit(result);
        break;
      case "setAudioContext":
        this.plugin.handleSetAudioContext(args, result);
        break;
      default:
        console.warn(`OHOS Plugin: Unhandled global method: ${call.method}`);
        result.notImplemented();
    }
  }
}

/** AudioplayersOhosPlugin **/
export default class AudioplayersOhosPlugin implements FlutterPlugin, MethodCallHandler {
  private channel: MethodChannel | null = null;
  private globalChannel: MethodChannel | null = null;
  private globalEventChannel: EventChannel | null = null;
  private globalEventHandler: GlobalEventStreamHandler = new GlobalEventStreamHandler();
  private players: Map<string, OHOSAudioPlayer> = new Map();
  private playerEventHandlers: Map<string, PlayerEventStreamHandler> = new Map();
  private binaryMessenger: BinaryMessenger | null = null;
  private globalMethodHandler: GlobalMethodCallHandler;

  constructor() {
    this.globalMethodHandler = new GlobalMethodCallHandler(this);
  }

  getUniqueClassName(): string {
    return "AudioplayersOhosPlugin"
  }

  onAttachedToEngine(binding: FlutterPluginBinding): void {
    this.binaryMessenger = binding.getBinaryMessenger();
    this.channel = new MethodChannel(this.binaryMessenger, "xyz.luan/audioplayers");
    this.channel.setMethodCallHandler(this);

    this.globalChannel = new MethodChannel(this.binaryMessenger, "xyz.luan/audioplayers.global");
    this.globalChannel.setMethodCallHandler(this.globalMethodHandler);

    this.globalEventChannel = new EventChannel(this.binaryMessenger, "xyz.luan/audioplayers.global/events");
    this.globalEventChannel.setStreamHandler(this.globalEventHandler);
  }

  onDetachedFromEngine(binding: FlutterPluginBinding): void {
    if (this.channel != null) {
      this.channel.setMethodCallHandler(null);
    }
    if (this.globalChannel != null) {
      this.globalChannel.setMethodCallHandler(null);
    }
    if (this.globalEventChannel != null) {
      // this.globalEventChannel.setStreamHandler(null);
    }
  }

  onMethodCall(call: MethodCall, result: MethodResult): void {
    const args = call.args as Record<string, Object>;

    console.error(`ğŸµ OHOS Plugin: Player method called: ${call.method}, args: ${JSON.stringify(args)}`);

    // å¤„ç†æ’­æ”¾å™¨æ–¹æ³• - ä½¿ç”¨ call.argument() æ–¹æ³•è·å–å‚æ•°
    const playerId = call.argument('playerId') as string;
    switch (call.method) {
      case "create":
        this.handleCreate(playerId, result);
        break;
      case "dispose":
        this.handleDispose(playerId, result);
        break;
      default:
        // å¯¹äºå…¶ä»–æ–¹æ³•ï¼Œéœ€è¦ç¡®ä¿æ’­æ”¾å™¨å­˜åœ¨
        const player = this.players.get(playerId);
        if (!player) {
          result.error('404', `Player ${playerId} not found`, null);
          return;
        }
        this.handlePlayerMethod(call, player, result);
    }
  }

  private handleCreate(playerId: string, result: MethodResult): void {
    if (this.players.has(playerId)) {
      result.success(null);
      return;
    }

    // åˆ›å»ºæ’­æ”¾å™¨äº‹ä»¶é€šé“
    const eventChannel = new EventChannel(this.binaryMessenger!, `xyz.luan/audioplayers/events/${playerId}`);
    const eventHandler = new PlayerEventStreamHandler();
    eventChannel.setStreamHandler(eventHandler);
    this.playerEventHandlers.set(playerId, eventHandler);

    const player = new OHOSAudioPlayer((event: string, value: AudioEventData) => {
      const eventData = new Map<string, Object>();
      eventData.set('event', event);

      // æ ¹æ®äº‹ä»¶ç±»å‹è®¾ç½®ä¸åŒçš„å€¼
      switch (event) {
        case 'audio.onPrepared':
          // å¯¹äº onPrepared äº‹ä»¶ï¼Œvalue åº”è¯¥æ˜¯ boolean
          eventData.set('value', true);
          break;
        case 'audio.onComplete':
          // å¯¹äº onComplete äº‹ä»¶ï¼Œvalue åº”è¯¥æ˜¯ boolean
          eventData.set('value', true);
          break;
        case 'audio.onDuration':
          // å¯¹äº onDuration äº‹ä»¶ï¼Œvalue åº”è¯¥æ˜¯ duration çš„æ¯«ç§’æ•°
          if (value.duration !== undefined) eventData.set('value', value.duration);
          break;
        default:
          // å¯¹äºå…¶ä»–äº‹ä»¶ï¼Œä½¿ç”¨åŸæ¥çš„é€»è¾‘
          if (value.state) eventData.set('value', value.state);
          if (value.code !== undefined) eventData.set('code', value.code);
          if (value.message) eventData.set('message', value.message);
          if (value.position !== undefined) eventData.set('value', value.position);
          break;
      }

      // å‘é€äº‹ä»¶åˆ°äº‹ä»¶é€šé“
      const eventObj: Record<string, Object> = {};
      eventData.forEach((value, key) => {
        eventObj[key] = value;
      });
      console.log(`ğŸµ Sending event: ${JSON.stringify(eventObj)}`);
      eventHandler.sendEvent(eventObj);
    });

    this.players.set(playerId, player);
    console.error(`ğŸµ OHOS Plugin: Created player ${playerId}`);
    result.success(null);
  }

  private handleDispose(playerId: string, result: MethodResult): void {
    const player = this.players.get(playerId);
    if (player) {
      player.release().then(() => {
        this.players.delete(playerId);
        this.playerEventHandlers.delete(playerId);
        console.error(`ğŸµ OHOS Plugin: Disposed player ${playerId}`);
        result.success(null);
      }).catch((err: Error) => {
        result.error('500', 'Failed to dispose player', err.message);
      });
    } else {
      result.success(null);
    }
  }

  handleGlobalInit(result: MethodResult): void {
    console.error(`ğŸµ OHOS Plugin: Global init called`);
    // æ¸…ç†æ‰€æœ‰ç°æœ‰æ’­æ”¾å™¨
    this.players.forEach((player: OHOSAudioPlayer, playerId: string) => {
      player.release().catch((err: Error) => {
        console.error(`Failed to release player ${playerId}: ${err.message}`);
      });
    });
    this.players.clear();
    result.success(null);
  }

  handleSetAudioContext(args: Record<string, Object>, result: MethodResult): void {
    console.error(`ğŸµ OHOS Plugin: setAudioContext called with args: ${JSON.stringify(args)}`);
    // OHOS æš‚ä¸æ”¯æŒå…¨å±€éŸ³é¢‘ä¸Šä¸‹æ–‡è®¾ç½®
    result.success(null);
  }

  private handlePlayerMethod(call: MethodCall, player: OHOSAudioPlayer, result: MethodResult): void {
    const args = call.args as Record<string, Object>;
    console.error(`ğŸµ OHOS Plugin: handlePlayerMethod - method: ${call.method}, args: ${JSON.stringify(args)}`);

    switch (call.method) {
      case "setSourceUrl":
        const url = call.argument('url') as string;
        const isLocal = call.argument('isLocal') as boolean;
        const mimeType = call.argument('mimeType') as string;
        console.error(`ğŸµ OHOS Plugin: setSourceUrl - url: ${url}, isLocal: ${isLocal}, mimeType: ${mimeType}`);
        player.setSourceUrl(url, isLocal).then(() => result.success(null)).catch((err: Error) => {
          result.error('500', 'Failed to set source URL', err.message);
        });
        break;
      case "play":
        player.play().then(() => result.success(null)).catch((err: Error) => {
          result.error('500', 'Failed to play', err.message);
        });
        break;
      case "pause":
        player.pause().then(() => result.success(null)).catch((err: Error) => {
          result.error('500', 'Failed to pause', err.message);
        });
        break;
      case "resume":
        player.resume().then(() => result.success(null)).catch((err: Error) => {
          result.error('500', 'Failed to resume', err.message);
        });
        break;
      case "stop":
        player.stop().then(() => result.success(null)).catch((err: Error) => {
          result.error('500', 'Failed to stop', err.message);
        });
        break;
      case "release":
        player.release().then(() => {
          result.success(null);
        }).catch((err: Error) => {
          result.error('500', 'Failed to release', err.message);
        });
        break;
      case "seek":
        const position = args['position'] as number;
        player.seek(position).then(() => result.success(null)).catch((err: Error) => {
          result.error('500', 'Failed to seek', err.message);
        });
        break;
      case "setVolume":
        const volume = args['volume'] as number;
        player.setVolume(volume).then(() => result.success(null)).catch((err: Error) => {
          result.error('500', 'Failed to set volume', err.message);
        });
        break;
      case "setPlaybackRate":
        const playbackRate = args['playbackRate'] as number;
        player.setPlaybackRate(playbackRate).then(() => result.success(null)).catch((err: Error) => {
          result.error('500', 'Failed to set playback rate', err.message);
        });
        break;
      case "getDuration":
        const duration = player.getDuration();
        result.success(duration);
        break;
      case "getCurrentPosition":
        const currentPosition = player.getCurrentPosition();
        result.success(currentPosition);
        break;
      case "setBalance":
        // OHOS æš‚ä¸æ”¯æŒéŸ³é¢‘å¹³è¡¡è®¾ç½®
        result.success(null);
        break;
      case "setPlayerMode":
        // OHOS æš‚ä¸æ”¯æŒæ’­æ”¾å™¨æ¨¡å¼è®¾ç½®
        result.success(null);
        break;
      case "setReleaseMode":
        // OHOS æš‚ä¸æ”¯æŒé‡Šæ”¾æ¨¡å¼è®¾ç½®
        result.success(null);
        break;
      case "setAudioContext":
        // OHOS æš‚ä¸æ”¯æŒéŸ³é¢‘ä¸Šä¸‹æ–‡è®¾ç½®
        result.success(null);
        break;
      case "setSourceBytes":
        // OHOS æš‚ä¸æ”¯æŒå­—èŠ‚æ•°ç»„éŸ³æº
        result.error('501', 'setSourceBytes not implemented on OHOS', null);
        break;
      default:
        console.warn(`OHOS Plugin: Unhandled method: ${call.method}`);
        result.notImplemented();
    }
  }
}